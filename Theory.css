/* селектор {  Селектор - что-то типа определителя (может быть по тегу, по классу, по уникальному идентификатору, дата-атрибуту) 
    свойство: значение;
    свойство: значение;
    свойство: значение;
} */

/* div a { }* Стилизуем вложенный элемент (конретно тег а) */

h2 {
    color: red;  /* Все заголовки красятся в красный цвет */
    font-size: 30; /* увеличили шрифт */
}

.chapter {
    color: blue; /* - использовали селектор по классу (т.е.стилизовали голубым цветом конретный заголовок с классом chapter) */
}

#begin {
    color: orange;  /* стилизовали по айдишнику (т.е стилизовали только тот тег, у которого есть id) */
}

/* Правила стилизации текста:

Цвет: варианты стилизации
    color: orange;
    color: #FFA07A;
    color: rgb(255,160,122);
    color: rgb(255,160,122, 0.5);
    словами (они зарезервированы в css)
    по 16теричному коду
    по rgb-формату
    по rgba -формату - то есть добавляется уровень прозрачности

Размещение на странице (по центру, слева, справа (распределение текста по ширине)
    text-align: left;
    text-align: center;
    text-align: right;
    text-align: justify; 

Жирность текста (можно указать словами а можно цифрами от 100 до 900 - степень жирности (не все варианты могут быть доступны))
    font-weight: normal;
    font-weight: bold;
    font-weight: 100;

Стиль текста
    font-style: italic; - курсив
    text-decoration: underline; - подчеркивание
    text-decoration: line-through; - зачеркивание текста

Размер шрифта (задаем в пискелях)
    font-size: 30px;
    text-transform: uppercase; - все прописные буквы
     
Все элементы на странице - прямоугольные (даже круги (то есть скругленные));

Контент имеет высоту и ширину;
Контент может иметь границу (border);
Между кондентом и границей может быть внутренний отступ (padding);
Может быть и внешний отступ (то есть отделение одного блока от другого)
Граница и отступы могут иметь 4 вида (правый, левый, нижний, верхний): right, left, bottom, top

Стилизация блоков по ширине, отступам и высоте;

.box {
    box-sizing: border-box; - сброс стандартных стилей (т.е. допустим ширина и длина будет та, которую установишь)
    width: 300px;
    height: 300px;

    background-color: green; - (цвет блока, а не текста);
    display: inline-block;
    vertical-inline: top; - это выравнивание элемента по вертикали (прижат к верху элемента). НО РАБОТАЕТ ТОЛЬКО ПРИ  display: inline-block У ЭЛЕМЕНТА, КОТОРЫЙ ВЫРАВНИВАЕМ
    vertical-inline: middle; это выравнивание элемента по вертикали(по центру). НО РАБОТАЕТ ТОЛЬКО ПРИ  display: inline-block У ЭЛЕМЕНТА, КОТОРЫЙ ВЫРАВНИВАЕМ

    padding-left: 30px; отступ слева, 
    padding-top: 20px; оступ сверху
    padding: 20px; - оступ со всех сторон;
    padding: 20px 50px; комбинированный вариант: сверху и снизу по 20, справа и слева по 50;
    padding: 20px 50px 30px 40px; - оступ сверху 20, справа 50, снизу 30 и слева 40 (т.е. идет сверху и по часовой);

    border-width: 3px; - ширина границы;
    border-style: solid; - тип границы(сплошная, прерывистая и т.д.);
    border-color: black; - цвет границы;
    border: 3px solid  black; - комбинированный вариант записи;

    margin: 20px;
    margin-left: 30px;
    margin: 30px 10px 40px 60px;  
    margin: 0 auto; - расположение по центру (по вертикали отступ 0, а по горизонтали auto); (только по горизонтали можно сделать.)
    z-index: 5; - расположение элемента по оси z, у кого больше индекс тот и будет выходить на первый план (принцип карточной колоды)
                    НО ЕСЛИ ЭЛЕМЕНТ АБСОЛЮТНО СПОЗИЦИОНИРОВАН В ОТНОШЕНИИ СВОЕГО РОДИТЕЛЯ, ТО ОН ВСНЕ РАВНО ГЛАВНЕЕ И БУДЕТ НА ПЕРВОМ ПЛАНЕ.
                    ЧТОБЫ ПОМЕСТИТЬ ЕГО НАЗАД, НУЖНО ИНДЕКС ЗАДАТЬ С ОТРИЦАТЕЛЬНЫМ ЗНАЧЕНИЕМ (-1).
                    НО ЕСЛИ У ВСЕХ ЭЛЕМНТОВ ПОЗИЦИОНИРОВАНИЕ БУДЕТ АБСОЛЮТНОЕ, ТО ТОГДА НА ПЕРВОМ ПЛАНЕ БУДЕТ ТОТ У КОГО ИНДЕКС БОЛЬШЕ
}

Все элементы на странице - это прямоугольники;
Все элементы на странице либо блочные, либо строчные либо блочно-строчные;  (display: block; inline; inline-block)

Блочные элементы занимают всю ширину страницы; ОНИ СКЕЛЕТ=КАРКАС СТРАНИЦЫ

Чтобы сбросить стандартное стили для всех элементов необходимо свойство box-sizing: border-box прописывать в самом начале файла и со *
   
*{
    box-sizing: border-box;
}

Строчные элементы - ЭТО НАПОЛЕНЕНИЕ СТРАНИЦЫ;
Занимают столько места, сколько необходимо для размещения контента;
Не реагируют на свойство ширины (т.е.все равно будут занимать столько, сколько занимает контент);
Марджины применяются только справа и слева (снизу и сверху не применяются);

Строчно-блочные элементы: комбинированный вариант, берет лучшее от блочных и от строчных элементов. */ 

/* nav {
    position: static; стоит по умолчанию (тоесть расположение такое, какое положено для данного элемента)
    position: relative; эта позиция позволяет в дальнейшем распологать элемент так как нужно нам. но сам элемент остается как бы в очередности документа (то есть он будет идти после того элемента, который мы прописали до него и перед тем элементом, который мы прописали после него.)
    left: 30px - то есть позиция relative позволяет нам прописать то, что мы хотим сдвинуть элемент меню вправо на 30 пикселей (то есть         отступили от левого края)
    right: 130px;
    top: 20px;
    bottom: 150px;
    position: absolute; - позволяет размещать элемент вне очереди документа, то есть можно разместить в абсолютно любом месте блока также используя (right, left, top, bottom) !РАБОТАЕТ ТОЛЬКО ВНУТРИ БЛОКА, У КОТОРОГО СТОИТ POSITION RELATIVE
    position: fixed; позволяет прилепить элемент к определенному месту (и этот лемент постоянно двигается вместе со страницей)
    position: inherit; наследует свойство от родителя.
}

img {
    float: left; - это обтекание текстом (либо другими элементами), т.е. в данном случае обтекание текстом справа

} */

/* .promo .promo_btn {
    cursor: pointer; - свойство курсора - замена при наведении на кнопку стрелочки рукой с указательным пальцем.
} */

ШРИФТ!

ОФОРМЛЕНИЕ МЕНЮ
.menu {
    
        display: flex;
        justify-content: space-between; (выравнивание в одну строку, для этого и ставим display: flex; у родителя (меню-родитель здесь))
        padding: 10px 70px;
        margin: 0;
        list-style-type: none; (убрали маркировку списка)
    
}
ПРОЗРАЧНОСТЬ ЭЛЕМЕНТА:

если нужно сделать прозрачным фон, а элементы на этом фоне не должны быть прозрачными, то лучше использовать не свойство opacity, а альфа-канал цвета
.subheader {
    height: 84px;
    background-color: rgba(0,0,0, .6);   прозрачность 60%
}

Чтобы картинка в случае ее замены не вылазила за отведенное под нее место, нужно устанавливать максимальную ширину в 100 процентов от отведенного места
.subheader .subheader_logo {
    max-width: 100%;
}

ПОДЛОЖКА ФОНА ПОД СОСЕДНЮЮ СЕКЦИЮ
1. ставим у родителя позицию относительную
2. у самого элемента, который хотим сместить ставим позицию абсолютную
3. самому элементу ставим ширину 100% от родителя.

header {
    position: relative;
}

.subheader {
    position: absolute;
    width: 100%;
    height: 84px;
    background-color: rgba(0,0,0, .6);
}

ФЛЕКСЫ
Чтобы использовать флексы у элементов, которые мы хотим выровнять должен быть родитель-обертка, к которому можно применить display: flex;

Есть 2 оси: главная и поперечная. По умолчанию главная - по горизионтали и элементы распределяются по ней.

ЭТО ВСЕ У РОДИТЕЛЯ ПРОПИСЫВАЕМ (КОНТЕЙНЕР, ОБЕРТКА)
Выравнивание элементов по горизонтали (по главной оси) - justify-content - прописывается опять же у родителя, может быть center (все лементы по центру контейнера), space-between (элементы равномерно распределятся по ширине контейнера), space-around (распределение по ширине страницы + оступы от краев контейнера), flex-start (вначале главной оси), flex-end (в конце главной оси)

Выравнивание элементов по вертикали (по поперечной оси) - align-items - также прописывается у родителя, может быть center, flex-start (вверху контейнера), flex-end (внизу контейнера), stretch (растягивалось на весь контейнер)
Если хотим, чтобы элементы переносились на новую строку (если не влазят на одну) то flex-wrap: wrap;

Если содержимое (контент) занимает несколько строк то, расположение может быть: align-content: stretch(содержимое растягивается), все остальные варианты - содержимое не растягивается flex-start (выравнивание начиная сверху контейнера), flex-end (начиная снизу контейнера), center(по центру), space-between (равномерно), space-around (равномерно с отступами от краев контейнера)

ТАКЖЕ МОЖНО МЕНЯТЬ ПОРЯДОК РАСПОЛОЖЕНИЯ ЭЛЕМЕНТОВ И ДР. (СМОТРИ ШПАРГАЛКУ)

